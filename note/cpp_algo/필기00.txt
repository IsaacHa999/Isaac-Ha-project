P14 operator()
    operator() 함수를 정의함으로써 객체를 함수처럼 사용할 수 있습니다. 이러한 패턴은 주로 함수 객체(Function Object)를 사용하는 경우에 많이 나타납니다. 

priority_queue<int, vector<int>, compare> MyQueue;
    int: 큐에 저장되는 원소의 타입입니다. 이 경우 int형으로 선언되어 있으므로 MyQueue는 int형 원소를 저장하는 우선순위 큐입니다.

    vector<int>: 내부적으로 사용되는 컨테이너 타입입니다. priority_queue는 기본적으로 내부적으로 vector를 사용하며, 여기서는 vector<int>를 명시적으로 사용하고 있습니다.

    compare: 비교 함수입니다. compare는 사용자가 정의한 구조체로, 이 구조체의 operator() 함수가 두 개의 int를 비교하여 우선순위를 정합니다

참조 매개변수 &
    참조 매개변수 (Reference Parameter): &
    별명(alias)을 사용하는 것과 같다.

최대 최소: min(), max() 함수, 리스트에서 적용 가능
    d = min({a,b,c});
    f = max({a,b,c});



// 에러나는 이유
2309번 백설공주와 일곱 난쟁이
    return 0; 의 오류
    끝나야할 시점에서 끝나야 한다.
예외처리
    같은 숫자가 나올 때
한 줄에서 끝 공백
줄 바꿈은 괜찮다!

배열의 크기가 너무 큰 경우 오류 나기도 하는 것 같다(스택 오버 플로우); --> vector


바킹독 알고리즘 베이직 강의
3강 배열
    c 에서 배열을 다룰 때에는 int arr[N]; 같은 동적 배열은 불가능하다 --> vector 사용해야 함
    fill(a, a + 21, 0);
    배열을 테이블로 사용하면 시간복잡도가 줄어들 수 있다.
    
4강 연결리스트
    배열이 아니라 연결리스트를 사용하는 이유: 삽입과 삭제가 많이 일어나는 경우 시간 복잡도를 고려해서 연결리스트를 사용한다.
    // 선언
    list<int> L = {1, 2};              
    list<int>::iterator t = L.begin();

    관련 메서드 암기

    야매 연결리스트(배열을 연결리스트 처럼 사용하기, 연결리스트를 직접 구현해야 할 경우)
    const int MX = 1000005;
    int dat[MX], pre[MX], nxt[MX];  // 배열 선언
    int unused = 1;
    fill(pre,pre + MX, -1);
    fill(nxt, nxt +MX, -1);
    
    이터레이터는 배열이랑 다르다, 주소의 개념?, 편의상 포인터로 생각하자
    리스트 관련 메서드, 이터레이터 동작원리 이해 필수 
    list.begin() 은 첫번째 원소를 가르키는 포인터, list.end()는 마지막 원소 + 1를 가르키는 포인터
    list.push_back, list.push_front, list.insert(), list.erase()
    for each를 사용

5 스택
    목적: 삽입, 삭제, 확인이 모두 O(1) 
    구현: 배열, 연결리스트 (배열을 권장)
    
    기본 구조
    배열로 구현
        const Mx = 1000001
        int dat[Mx];
        int pos = 0; 
    리스트로 구현

    스택 문제 스킬
        <그림>: 
        pop() 조건
        push() 조건
        출력 결과

        처음에 원소 한 개를 넣고 시작하는 기술      // empty를 방지하는 기술
        오름차순/내림차순으로 정렬하는 기술
        pair(value,index)를 활용하는 기술
    예제1
        최댓값만 활용하는 경우(내림차순 정렬)
    예제2

6 큐
    큐의 이미지 통일할 것!!
        스택과, 큐의 데이터 이미지는 통일하고, 연산의 모습만 달라지게!
        10 20 30 40 

7 덱
    예제
        오름차순 정렬, pair<int,int> 인덱스 사용
        
8 스택의 활용
    getline(cin, a)   // string a;

9강 BFS
    floodfill 문제 해결법
    복습 필요

    더 많이 사용, 거리 측정이 가능하다
0xA강 DFS

0xB강 재귀

0xC강 백트래킹

0xD강 시뮬레이션
    특정 자료구조에 종속되지 않은 문제
    각 변수가 독립적이라면 백트래킹 대신 진법을 사용한다.

0xE강 정렬 1
    직접 짤 경우 퀵 소트 사용하지 말기

0xF강
    카운팅 소트와
    라딕스 소트(기수정렬)
STL sort
    sort(a, a+5)
    sort(b.begin(), b.end());
    stable_sort?
    pair, tuple : 앞의 대소를 비교하는 방식으로 정해져 있음
    비교함수를 내가 정해서 넘겨줄 수 있음

0x10 다이나믹 프로그래밍
    DP를 푸는 과정
        1. 테이블 정의하기
        2. 점화식 찾기
        3. 초기값 정하기
0x11 그리디
    거의 똑같은 문제를 풀어봤거나 간단한 문제여서서 나의 풀이를 100% 확신한다 
        -> 짜서 제출해보고 아니면 빠르게 손절
    100% 확신은 없지만 맞는 것 같은 그리디 풀이를 찾았다 
        --> 일단은 넘어가자
    그리디는 오류를 찾아서 해결하기 매우 힘들다
    
    귀류법
    greedy criterion(탐욕기준)
0x12 수학
    출게 경향 낮음
    유형
        소수
            소수 판정법 : 루트n을 사용하는 방법
            에라토스테네스의 체
            소인수분해
        최대공약수
            약수
            GCD
            유클리드 호제법
                재귀로 구현, 
        연립합동방정식
            ~
        이향계수
    수학은 수학 경시대회의 아이디어를 활용하는 경우 있음
    지엽적인 문제를 풀어야 하는 경우 있음
0x13 이분 탐색
    기본은 쉽다
    조금만 응용을 해도 매우 어려워 진다(킬러문제)
    개념이랑 stl 사용법만 익히고 넘어가도 된다.
    
    구현 및 STL
        binary_search(a, b, c);
        lower_idx(a,b)
        upper_idx(a,b)

    이분 탐색은 다른 소트와 다르게 구체적으로 짤 수 있어야 한다

    주의사항
        정렬이 선행
        무한루프에 빠지지 않게 mid값을 조정해야 한다.
    
    고난도
        좌표압축

    Parametric binary_search   
        조건을 만족하는 최소/쇠대 문제(최적화 문제)를 결정 문제로 변환해 이분탐색을
        수행하는 방법
0x14강 투 포인터 알고리즘
    인덱스 하나의 차이로 답이 나오는 경우 많음
    이중 for문 
    이분 탐색과 관련이 있다
    부분합
0x15강 해시
    자료구조 
        해시 ,이진 검색 트리, 힙
    정의와 성질
        해시는 모든 연산이 O(1) 이다
    stl
        unordered_set<int> s;   //중복x
        s.insert(10);
        s.erase(100);
        s.size();
        s.count(50);
        출력에서 순서는 랜덤

        unordered_multiset_example()    // 중복 허용
        erase가 전부 삭제를 한다

        unordered_map<string, ing> m;
    연습 문제
    구현

    
